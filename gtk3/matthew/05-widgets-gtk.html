<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Виджеты GTK+</title>

    <link href="../../favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon" />

    <link href="../../css/bootstrap.css" rel="stylesheet">
    <link href="../../css/librebay.css" rel="stylesheet">

    <link href="../../css/highlight.css" rel="stylesheet">
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body>

    <div class="container" role="main">



<h1 id="widgets-gtk">Виджеты GTK+</h1>

<p>В этом разделе мы рассмотрим API самых популярных виджетов GTK+, которые вы будете применять чаще всего в своих приложениях.</p>

<h2 id="gtkwindow">GtkWindow</h2>

<p><code>GtkWindow</code> &mdash; базовый элемент всех приложений GTK+. До сих пор вы использовали его для хранения своих виджетов.</p>

<pre><code class="nohighlight">GObject
╰── GInitiallyUnowned
    ╰── GtkWidget
        ╰── GtkContainer
            ╰── GtkBin
                ╰── GtkWindow
</code></pre>

<p>Существуют десятки вызовов API <code>GtkWindow</code>, но далее приведены функции, заслуживающие особого внимания.</p>

<pre><code class="C">GtkWidget *gtk_window_new              (GtkWindowType type);
void       gtk_window_set_title        (GtkWindow *window, const gchar *title);
void       gtk_window_set_position     (GtkWindow *window, GtkWindowPosition position);
void       gtk_window_set_default_size (GtkWindow *window, gint width, gint height);
void       gtk_window_resize           (GtkWindow *window, gint width, gint height);
void       gtk_window_set_resizable    (GtkWindow *window, gboolean resizable);
void       gtk_window_present          (GtkWindow *window);
void       gtk_window_maximize         (GtkWindow *window);
void       gtk_window_unmaximize       (GtkWindow *window);
</code></pre>

<p>Как вы видели, функция <code>gtk_window_new</code> создаёт в памяти новое пустое окно. Заголовок окна не задан и местоположение окна не определены. Обычно вы будете заполнять окно виджетами и задавать меню и панель инструментов перед выводом окна на экран с помощью вызова функции <code>gtk_widget_show</code>.</p>

<p>Функция <code>gtk_window_set_title</code> изменяет текст полосы заголовка, информируя оконный менеджер запроса.</p>

<blockquote>
<p><em>Примечание</em></p>

<p>Поскольку за отображение оформления окна отвечает оконный менеджер, а не библиотека GTK+, шрифт, цвет и размер текста зависят от вашего выбора оконного менеджера.</p>
</blockquote>

<p>Функция <code>gtk_window_set_position</code> управляет начальным местоположением на экране. Параметр <code>position</code> может принимать пять значений, перечисленных в табл. 1.</p>

<table class="table">
<caption>Таблица 1.</caption>
<colgroup>
<col class="col-md-4">
<col class="col-md-8">
</colgroup>
<thead>
<tr>
<th>Параметр <code>position</code></th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GTK_WIN_POS_NONE</code></td>
<td>Окно располагается по усмотрению оконного менеджера</td>
</tr>
<tr>
<td><code>GTK_WIN_POS_CENTER</code></td>
<td>Окно центрируется на экране</td>
</tr>
<tr>
<td><code>GTK_WIN_POS_MOUSE</code></td>
<td>Расположение окна задается указателем мыши</td>
</tr>
<tr>
<td><code>GTK_WIN_POS_CENTER_ALWAYS</code></td>
<td>Окно остаётся отцентрированным независимо от его размера</td>
</tr>
<tr>
<td><code>GTK_WIN_POS_CENTER_ON_PARENT</code></td>
<td>Окно центрируется относительно родительского окна (удобно для диалоговых окон)</td>
</tr>
</tbody>
</table>

<p>Функция <code>gtk_window_set_default_size</code> задаёт окно на экране в единицах отображения GTK+. Явное задание размера окна гарантирует, что содержимое окна не будет закрыто чем-либо или скрыто. Для того чтобы изменить размеры окна после его вывода на экран, можно воспользоваться функцией <code>gtk_window_resize</code>. По умолчанию пользователь может изменить размер окна, перемещая обычным способом его границу мышью. Если вы хотите помешать этому, можно вызвать функцию <code>gtk_window_set_resizable</code>, приравненную <code>FALSE</code>.</p>

<p>Для того чтобы убедиться в том, что ваше окно присутствует на экране и видно пользователю, т.е. не свернуто или скрыто, подойдет функция <code>gtk_window_present</code>. Она полезна для диалоговых окон, т.е. позволяет убедиться в том, что она не свернуты, когда вам нужен какой-либо пользовательский ввод. В противном случае, для раскрытия окна на весь экран и его сворачивания у вас есть функции <code>gtk_window_maximize</code> и <code>gtk_window_unmaximize</code>.</p>

<h2 id="gtkentry">GtkEntry</h2>

<p><code>GtkEntry</code> &mdash; виджет однострочного текстового поля, который обычно применяется для ввода простых текстовых данных, например, адреса электронной почты, имени пользователя или имени узла сети. Существуют вызовы API, позволяющие задать как считывание введенного текста, так и его максимальную длину в символах, а также другие параметры, управляющие местоположением текста и его выделением.</p>

<pre><code class="nohighlight">GObject
╰── GInitiallyUnowned
    ╰── GtkWidget
        ╰── GtkEntry
</code></pre>

<p>Можно настроить <code>GtkEntry</code> на отображение звёздочек (или любого другого определенного пользователем символа) на месте набранных буквенно-цифровых символов, что очень удобно для ввода паролей, когда вы не хотите, чтобы кто-то заглядывал через ваше плечо и читал текст.</p>

<p>Мы опишем большинство самых полезных функций виджета <code>GtkEntry</code>:</p>

<pre><code class="C">GtkWidget   *gtk_entry_new                (void);
void         gtk_entry_set_max_length     (GtkEntry *entry, gint max);
const gchar *gtk_entry_get_text           (GtkEntry *entry);
void         gtk_entry_set_text           (GtkEntry *entry, const gchar *text);
void         gtk_entry_set_visibility     (GtkEntry *entry, gboolean visible);
void         gtk_entry_set_invisible_char (GtkEntry *entry, gunichar ch);
</code></pre>

<p>Вы можете создавать <code>GtkEntry</code> с помощью функции <code>gtk_entry_new</code>. Функцией <code>gtk_entry_set_max_length</code> можно настроить ввод текста фиксированной длины. Ограничение ввода определенной длинной текста избавит вас от проверки корректности длины ввода и, возможно, необходимости информировать пользователя о том, что текст слишком длинный.</p>

<p>Для получения содержимого виджета <code>GtkEntry</code> вызывайте функцию <code>gtk_entry_get_text</code>, которая возвращает указатель <code>const gchar</code>, внутренний по отношению к <code>GtkEntry</code>. Если вы хотите изменить текст или передать его в функцию, которая может его модифицировать, следует скомпилировать строку с помощью, например, функции <code>strcpy</code>.</p>

<p>Вы можете вручную задать содержимое виджета <code>GtkEntry</code>, применив функцию <code>gtk_entry_set_text</code>. Учтите, что она принимает указатель <code>const gchar</code>.</p>

<h3 id="example-username-and-password-entry">Пример: ввод имени пользователя и пароля</h3>

<p>Теперь, познакомившись с функциями виджета <code>GtkEntry</code>, посмотрим на них в действии в небольшой программе. Программа <code>gtk_entry.c</code> будет создавать окно ввода имени пользователя и пароля и сравнивать введенный пароль с секретным.</p>

<ol>
<li>
<p>Сначанала определим секретный пароль, остроумно заданный как <code>secret</code>:</p>
<pre><code class="C">#include &lt;gtk/gtk.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const char *password = &quot;secret&quot;;
</code></pre>
</li>
<li>
<p>У вас есть две функции обратно вызова, которые вызываются, когда уничтожается окно и щелкатеся мышью кнопка "OK":</p>
<pre><code>void closeApp(GtkWidget *window, gpointer data)
{
    gtk_main_quit();
}

void button_clicked(GtkWidget *button, gpoвinter data)
{
    const char *password_text = gtk_entry_get_text(GTK_ENTRY((GtkWidget *)data));

    if (strcmp(password_text, password) == 0)
        printf(&quot;Access granted!\n&quot;);
    else
        printf(&quot;Access denied!\n&quot;);
}
</code></pre>
</li>
<li>
<p>В функции <code>main</code> создаётся, компонуется интерфейс и связываются обратные вызовы с сигналами. Для компоновки виджетов меток и полей ввода примените виджеты-контейнеры <code>GtkBox</code>:</p>
<pre><code>int main(int argc, char *argv[])
{
    GtkWidget *window;
    GtkWidget *username_label, *password_label;
    GtkWidget *username_entry, *password_entry;
    GtkWidget *ok_button;
    GtkWidget *hbox1, *hbox2;
    GtkWidget *vbox;

    gtk_init(&amp;argc, &amp;argv);

    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(window), &quot;GtkEntryBox&quot;);
    gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
    gtk_window_set_default_size(GTK_WINDOW(window), 200, 200);
    gtk_container_set_border_width(GTK_CONTAINER(window), 10);

    g_signal_connect(G_OBJECT(window), &quot;destroy&quot;, G_CALLBACK(closeApp), NULL);

    username_label = gtk_label_new(&quot;Login: &quot;);
    password_label = gtk_label_new(&quot;Password: &quot;);

    gtk_label_set_width_chars(GTK_LABEL(username_label), 12);
    gtk_label_set_width_chars(GTK_LABEL(password_label), 12);

    username_entry = gtk_entry_new();
    password_entry = gtk_entry_new();
    gtk_entry_set_visibility(GTK_ENTRY(password_entry), FALSE);

    ok_button = gtk_button_new_with_label(&quot;OK&quot;);

    g_signal_connect(G_OBJECT(ok_button), &quot;clicked&quot;, G_CALLBACK(button_clicked), password_entry);

    hbox1 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);
    hbox2 = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 5);

    vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);

    gtk_box_pack_start(GTK_BOX(hbox1), username_label, TRUE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(hbox1), username_entry, TRUE, FALSE, 5);

    gtk_box_pack_start(GTK_BOX(hbox2), password_label, TRUE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(hbox2), password_entry, TRUE, FALSE, 5);

    gtk_box_pack_start(GTK_BOX(vbox), hbox1, FALSE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(vbox), hbox2, FALSE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(vbox), ok_button, FALSE, FALSE, 5);

    gtk_container_add(GTK_CONTAINER(window), vbox);

    gtk_widget_show_all(window);

    gtk_main();

    return 0;
}
</code></pre>
</li>
</ol>

<p>Когда вы запустите программу, то получите окно, показанное на рис. 1.</p>

<figure>
<img src="images/gtk_entry.png" alt="Рис. 1. Ввод имени пользователя и пароля, используя GtkEntry" />
<figcaption>Рис. 1. Ввод имени пользователя и пароля, используя GtkEntry</figcaption>
</figure>

<h4 id="how-it-works">Как это работает</h4>

<p>Программа создает два виджета типа <code>GtkEntry</code>, <code>username_entry</code> и <code>password_entry</code>, а также задает видимость <code>password_entry</code>, равной <code>FALSE</code>, чтобы скрыть введенный пароль. Затем она формирует кнопку <code>GtkButton</code>, с помощью которой вы связываете сигнал <code>clicked</code> с функцией обратного вызова <code>button_clicked</code>.</p>

<p>Как только в функции обратного вызова программа извлечет введенный пароль и сравнит его с секретным паролем, на экран выводится соответствующее сообщение.</p>

<p>Обратите внимание на то, что для вставки виджетов в свои контейнеры вы много раз повторили операторы <code>gtk_box_pack_start</code>. Для сокращения этого повторяющегося программного кода в последующих примерах будет определена вспомогательная функция.</p>

<h2 id="gtkspinbutton">GtkSpinButton</h2>

<p>Порой вам нужно, чтобы пользователь ввел числовое значение, например, максимальную скорость или размер инструмента, и в такой ситуации виджет <code>GtkSpinButton</code> (кнопка-счетчик) идеален. Он ограничивает ввод пользователя только цифровыми символами и можно задать диапазон допустимых значений от нижней до верхней границы. Виджет также содержит кнопки, плюс и минус, так что пользователь может &#8220;накручивать&#8221; значение, для удобства пользуясь только мышью.</p>

<pre><code class="nohighlight">GObject
╰── GInitiallyUnowned
    ╰── GtkWidget
        ╰── GtkEntry
            ╰── GtkSpinButton
</code></pre>

<p>И снова API понятен, и мы перечислим наиболее часто применяемые вызовы:</p>

<pre><code class="C">GtkWidget *gtk_spin_button_new (GtkAdjustment *adjustment, gdouble climb_rate, guint digits);
GtkWidget *gtk_spin_button_new_with_range (gdouble min, gdouble max, gdouble step);

void    gtk_spin_button_set_digits       (GtkSpinButton *spin_button, guint digits);
void    gtk_spin_button_set_increments   (GtkSpinButton *spin_button, gdouble step, gdouble page);
void    gtk_spin_button_set_range        (GtkSpinButton *spin_button, gdouble min, gdouble max);
gdouble gtk_spin_button_get_value        (GtkSpinButton *spin_button);
gint    gtk_spin_button_get_value_as_int (GtkSpinButton *spin_button);
void    gtk_spin_button_set_value        (GtkSpinButton *spin_button, gdouble value);
</code></pre>

<p>Для создания виджета типа <code>GtkSpinButton</code> с помощью функции <code>gtk_spin_button_new()</code> вы сначала должны создать объект <code>GtkAdjustment</code>. Виджет <code>GtkAdjustment</code> &mdash; это абстрактный объект содержащий логику, касающуюся управления значениями с ограничениями. Он также применяется и в других виджетах, например, <code>GtkScale</code>.</p>

<p>Для создания объекта типа <code>GtkAdjustment</code> передайте в функцию нижнюю и верхнюю границы и размер приращения.</p>

<pre><code>GtkAdjustment *
gtk_adjustment_new (gdouble value,          // Начальное значение
                    gdouble lower,          // Минимальное значение
                    gdouble upper,          // Максимальное значение
                    gdouble step_increment, // Шаг приращения
                    gdouble page_increment, // Страничное приращение
                    gdouble page_size);     // Размер страницы
</code></pre>

<p>Значения параметров <code>step_increment</code> и <code>page_increment</code> задают величину минимального и максимального приращений. В случае кнопки-счетчика <code>GtkSpinButton</code> параметр <code>step_increment</code> определяет, насколько изменится значение при щелчке мышью по кнопкам виджета. Параметры <code>page_increment</code> и <code>page_size</code> в виджетах <code>GtkSpinButton</code> не важны.</p>

<p>Второй параметр, <code>climb_rate</code>, в функции <code>gtk_spin_button_new()</code> управляет скоростью прокрутки значений при нажатии и удерживании кнопки со стрелкой. И наконец, параметр <code>digits</code> задаёт точность представления числового значения виджета, если, например, <code>digits</code> равен 2, кнопка-счетчик отобразит <code>0.00</code>.</p>

<p>Функция <code>gtk_spin_button_new_with_range()</code> &mdash; удобный способ создания объекта <code>GtkSpinButton</code>. Просто задайте нижнюю и верхнюю границы и величину приращения.</p>

<p>Прочесть текущее значение очень легко благодаря функции <code>gtk_spin_button_get_value()</code>, а если вам нужно целое число, можно применить функцию <code>gtk_spin_button_get_value_as_int()</code>.</p>

<h3 id="example-use-gtkspinbutton">Пример: использование виджета GtkSpinButton</h3>

<p>Сейчас мы посмотрим в коротком примере, как действует кнопка-счётчик <code>GtkSpinButton</code>. Назовите файл <code>gtk_spin.c</code>.</p>

<pre><code class="C">#include &lt;gtk/gtk.h&gt;

void closeApp(GtkWidget *window, gpointer data)
{
    gtk_main_quit();
}


int main(int argc, char *argv[])
{
    GtkWidget *window;
    GtkWidget *spinbutton;
    GtkAdjustment *adjustment;

    gtk_init(&amp;argc, &amp;argv);
    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    gtk_window_set_title(GTK_WINDOW(window), &quot;GtkSpinButton&quot;);
    gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
    gtk_window_set_default_size(GTK_WINDOW(window), 300, 200);
    gtk_container_set_border_width(GTK_CONTAINER(window), 10);

    g_signal_connect(G_OBJECT(window), &quot;destroy&quot;, G_CALLBACK(closeApp), NULL);

    adjustment = gtk_adjustment_new(100.0, 50.0, 150.0, 0.5, 1.0, 1.0);
    spinbutton = gtk_spin_button_new(adjustment, 0.01, 2);

    gtk_container_add(GTK_CONTAINER(window), spinbutton);

    gtk_widget_show_all(window);

    gtk_main();

    return 0;
}
</code></pre>

<p>Когда вы выполните программу, по получите кнопку-счётчик, ограниченную диапазонов значений 50&ndash;150 (рис. 2).</p>

<figure>
<img src="images/gtk_spin_button.png" alt="Рис. 2. Использование виджета GtkSpinButton" />
<figcaption>Рис. 2. Использование виджета GtkSpinButton</figcaption>
</figure>

<hr />

<p>Назад: <a href="04-packing-box-widgets.html">Виджеты упаковочных контейнеров</a></p>

<p>Вернуться <a href="../../index.html">на главную страницу</a>.</p>



    </div>
    <script src="../../js/jquery.js"></script>
    <script src="../../js/bootstrap.js"></script>
  </body>
</html>
