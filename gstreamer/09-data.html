<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Фреймворк GStreamer. Руководство разработчика приложений. Буферы и события</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/librebay.css" rel="stylesheet">

    <link href="../css/highlight.css" rel="stylesheet">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body>

    <div class="container" role="main">



<h1 id="h1-buffers-and-events">Фреймворк GStreamer. Руководство разработчика приложений. Буферы и события</h1>

<p>Оригинал: GStreamer Application Development Manual<br/>
Авторы: Wim Taymans, Steve Baker, Andy Wingo, Ronald S. Bultje, Stefan Kost<br/>
Дата публикации: 21 мая 2014 г.<br/>
Перевод: А.Панин<br/>
Дата перевода: 19 июня 2014 г.<br/>
Оригинал перевода: <a href="http://rus-linux.net/MyLDP/BOOKS/gstreamer/09-data.html">Фреймворк GStreamer. Руководство разработчика приложений. Буферы и события</a></p>

<h2 id="buffers-and-events">Глава 9. Буферы и события</h2>

<p>Процесс передачи данных по конвейеру тесно связан с использованием комбинации буферов и событий. Буферы содержат сами мультимедийные данные. События используются для передачи такой управляющей информации, как информация о перемещении в потоке данных и уведомления о завершении этого потока. Все операции передачи данных в рамках конвейера выполняются автоматически в процессе работы конвейера. Данная глава предназначена в первую очередь для объяснения принципов работы описанного механизма; вам не придется как-либо вмешиваться в его работу.</p>

<h3 id="buffers">9.1. Буферы</h3>

<p>Буферы содержат данные, которые будут передаваться посредством созданного вами конвейера. Элемент для ввода данных обычно создает новый буфер и передает его с помощью точки соединения следующему элементу в цепочке. При использовании инфраструктуры фреймворка GStreamer для создания конвейера обработки мультимедийных данных вам не придется работать с буферами самостоятельно; элементы сделают это за вас.</p>

<p>Помимо прочих вещей, буфер состоит из:</p>

<ul>
<li><p>Указателей на объекты памяти. Объекты памяти инкапсулируют фрагмент памяти.</p></li>
<li><p>Метки времени для буфера.</p></li>
<li><p>Счетчика ссылок, который указывает на то, как много элементов использует данный буфер. Этот счетчик ссылок будет использоваться для уничтожения буфера в момент, когда на него не будет ссылаться ни один из элементов.</p></li>
<li><p>Флагов буфера.</p></li>
</ul>

<p>В простейшем случае при создании буфера для него резервируется память, в нее помещаются данные, после чего буфер передается следующему элементу. Этот элемент читает данные, выполняет с ними какие-либо действия (такие, как декодирование с записью результирующих данных в предварительно созданный новый буфер) и удаляет ссылку на полученный буфер. Это действие приводит к освобождению зарезервированной для хранения данных памяти и уничтожению буфера. Типичный декодер аудио- или видеопотоков работает именно так.</p>

<p>Хотя существуют и более сложные сценарии. Элементы могут непосредственно модифицировать данные буферов, т.е., изменять данные без резервирования нового буфера. Также элементы могут записывать данные в область памяти, связанную с аппаратным обеспечением (в такую, как память устройств видеозахвата) или зарезервированную сервером оконной системы X (с использованием расширения XShm). Буферы могут предназначаться как только для чтения данных из них, так и для других операций.</p>

<h3 id="events">9.2. События</h3>

<p>События являются сигналами управления, которые отправляются как по направлению, так и против направления конвейера вместе с буферами. События, отправляемые по направлению конвейера, уведомляют целевые элементы об изменениях состояния потока. Набор возможных вариантов событий включает события перемещения в потоке, события опустошения буферов, события окончания потока и.т.д. События, отправляемые против направления конвейера, используются для осуществления взаимодействий как по схеме приложение-элемент, так и по схеме элемент-элемент с целью запроса выполнения таких изменений состояния потока, как переходы к заданным позициям. Для приложений важны исключительно события, отправляемые против направления конвейера. События, отправляемые по направлению конвейера, описаны только для того, чтобы читатель составил более полное представление о концепции механизма передачи данных.</p>

<p>Так как большая часть приложений использует единицы измерения времени для перехода к заданной позиции в потоке, в нашем примере они также будут использоваться:</p>

<pre><code>static void
seek_to_time (GstElement *element,
          guint64     time_ns)
{
  GstEvent *event;

  event = gst_event_new_seek (1.0, GST_FORMAT_TIME,
                  GST_SEEK_FLAG_NONE,
                  GST_SEEK_METHOD_SET, time_ns,
                  GST_SEEK_TYPE_NONE, G_GUINT64_CONSTANT (0));
  gst_element_send_event (element, event);
}
</code></pre>

<p>Функция <code>gst_element_seek ()</code> является вспомогательной функцией, позволяющей использовать описанную методику перехода к позиции в потоке. Этот пример приведен главным образом для демонстрации методики работы с событиями.</p>

<hr />

<p>Предыдущий раздел : <a href="08-pads.html">Точки соединения и возможности</a></p>

<p>Следующий раздел : <a href="10-helloworld.html">Ваше первое приложение</a></p>

<p>Главная страница : <a href="../index.html">http://neon1ks.github.io/</a></p>



    </div>
    <script src="../js/jquery.js"></script>
    <script src="../js/bootstrap.js"></script>
  </body>
</html>
