<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Фреймворк GStreamer. Руководство разработчика приложений. Шина сообщений</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/librebay.css" rel="stylesheet">

    <link href="../css/highlight.css" rel="stylesheet">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body>

    <div class="container" role="main">



<h1 id="h1-bus">Фреймворк GStreamer. Руководство разработчика приложений. Шина сообщений</h1>

<p>Оригинал: GStreamer Application Development Manual<br/>
Авторы: Wim Taymans, Steve Baker, Andy Wingo, Ronald S. Bultje, Stefan Kost<br/>
Дата публикации: 21 мая 2014 г.<br/>
Перевод: А.Панин<br/>
Дата перевода: 19 июня 2014 г.<br/>
Оригинал перевода: <a href="http://rus-linux.net/MyLDP/BOOKS/gstreamer/07-bus.html">Фреймворк GStreamer. Руководство разработчика приложений. Шина сообщений</a></p>

<h2 id="bus">Глава 7. Шина сообщений</h2>

<p>Шина сообщения является простой системой, ответственной за передачу сообщений от программных потоков, предназначенных для обработки мультимедийных потоков, в контекст программного потока приложения. Преимущество использования шины сообщений заключается в отказе от обязательного создания многопоточных приложений для работы с фреймворком GStreamer, несмотря на то, что сам фреймворк GStreamer активно использует программные потоки.</p>

<p>Каждый конвейер по умолчанию содержит шину сообщений, поэтому приложения не должны создавать шины сообщений или другие примитивы взаимодействия самостоятельно. Единственная задача, которую должно выполнить приложение, заключается в установке обработчика для передаваемых посредством шины сообщений, причем этот обработчик аналогичен обработчику сигналов для объекта. В процессе работы главного цикла обработки событий шина сообщений будет периодически проверяться на наличие новых сообщений и функция обратного вызова будет активироваться каждый раз, когда будет доступно новое сообщение.</p>

<h3 id="how-to-use-a-bus">7.1. Как использовать шину сообщений</h3>

<p>Существует два различных подхода к использованию шины сообщений:</p>

<ul>
<li><p>Запуск главного цикла обработки событий GLib/Gtk+ (или самостоятельный постоянный итерационный обход событий стандартного главного контекста GLib) с последующей установкой механизма какого-либо типа для наблюдения за состоянием шины сообщений. Это метод, который главный цикл обработки событий GLib будет использовать для проверки наличия новых сообщений на шине сообщений и уведомления вас в случае наличии таких сообщений.</p>

<p>Обычно в подобных случаях приходится использовать функцию <code>gst_bus_add_watch()</code> или <code>gst_bus_add_signal_watch()</code>.</p>

<p>Для использования шины сообщений следует соединить обработчик событий с объектом шины сообщений конвейера с помощью функции <code>gst_bus_add_watch()</code>. Этот обработчик будет вызываться тогда, когда конвейер будет генерировать сообщение и передавать его посредством шины сообщений. В рамках данного обработчика следует проверить тип сигнала (об этом будет сказано в следующем разделе) и выполнить какие-либо действия в зависимости от типа сообщения. Обработчик сигнала должен возвращать логическое значение <code>TRUE</code> для продолжения обработки событий шины или логическое значение <code>FALSE</code> для отсоединения обработчика.</p></li>
<li><p>Самостоятельная проверка наличия сообщений на шине. При выполнении этой операции должны использоваться функции gst_bus_peek () и/или gst_bus_poll ().</p></li>
</ul>

<pre><code>#include &lt;gst/gst.h&gt;

static GMainLoop *loop;

static gboolean
my_bus_callback (GstBus     *bus,
         GstMessage *message,
         gpointer    data)
{
  g_print (&quot;Получено сообщение типа %s\n&quot;, GST_MESSAGE_TYPE_NAME (message));

  switch (GST_MESSAGE_TYPE (message)) {
    case GST_MESSAGE_ERROR: {
      GError *err;
      gchar *debug;

      gst_message_parse_error (message, &amp;err, &amp;debug);
      g_print (&quot;Ошибка: %s\n&quot;, err-&gt;message);
      g_error_free (err);
      g_free (debug);

      g_main_loop_quit (loop);
      break;
    }
    case GST_MESSAGE_EOS:
      /* Окончание мультимедийного потока */
      g_main_loop_quit (loop);
      break;
    default:
      /* Необработанное сообщение */
      break;
  }

  /* мы хотим получать уведомление при поступлении следующего сообщения посредством
   * шины сообщений, поэтому возвращаем TRUE (FALSE возвращается для прекращения
   * отслеживания сообщений на шине, при этом наша функция обратного вызова более
   * не должна вызываться)
   */
  return TRUE;
}

gint
main (gint   argc,
      gchar *argv[])
{
  GstElement *pipeline;
  GstBus *bus;
  guint bus_watch_id;

  /* Инициализация */
  gst_init (&amp;argc, &amp;argv);

  /* Создание конвейера, добавление обработчика */
  pipeline = gst_pipeline_new (&quot;my_pipeline&quot;);

  /* добавление функции отслеживания новых сообщений для шины сообщений нашего
   * конвейера в стандартный главный контекст GLib, который является главным
   * контекстом, к которому впоследствии будет присоединяться главный цикл
   * обработки событий GLib
   */
  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
  bus_watch_id = gst_bus_add_watch (bus, my_bus_callback, NULL);
  gst_object_unref (bus);

[..]

  /* создание главного цикла обработки событий, который функционирует в рамках
   * стандартного главного контекста GLib (контекста NULL), другими словами:
   * в рамках контекста будет проводиться проверка наступления какого-либо события,
   * за которым осуществляется наблюдение.
   * При передаче сообщения посредством шины стандартный главный контекст
   * автоматически вызовет нашу функцию обратного вызова my_bus_callback()
   * для уведомления нас о поступлении данного сообщения.
   * Главный цикл обработки событий будет работать до того момента,
   * когда кто-либо вызовет функцию g_main_loop_quit()
   */
  loop = g_main_loop_new (NULL, FALSE);
  g_main_loop_run (loop);

  /* Освобождение ресурсов */
  gst_element_set_state (pipeline, GST_STATE_NULL);
  gst_object_unref (pipeline);
  g_source_remove (bus_watch_id);
  g_main_loop_unref (loop);

  return 0;
}
</code></pre>

<p>Важно знать о том, что обработчик сигналов будет вызываться в контексте программного потока главного цикла обработки событий. Это означает, что взаимодействие между конвейером и приложением посредством шины сообщений будет осуществляться в <em>асинхронном режиме</em> и, следовательно, шина сообщений не может использоваться для выполнения некоторых операций реального времени, таких, как сведение аудиотреков, воспроизведение потоков без перерывов (в теории) или наложение эффектов на видео. Все подобные операции должны выполняться в контексте конвейера, что проще всего сделать, разработав плагин для фреймворка GStreamer. При этом шина сообщений отлично выполняет свою основную задачу: передает сообщения от конвейера приложению. Преимущество использованного механизма передачи сообщений заключается в том, что вся работа с программными потоками выполняется в рамках фреймворка GStreamer и скрыта от приложения, поэтому разработчик приложения вообще не должен беспокоиться о реализации механизмов управления программными потоками.</p>

<p>Учтите, что в том случае, если вы интегрируете код обработки сообщений в главный цикл обработки событий GLib, вы можете вместо начала отслеживания сообщений установить обработчик для сигнала &#8220;message&#8221; объекта шины сообщений. В этом случае вам не придется использовать оператор <code>switch()</code> для обработки всех существующих типов сообщений; следует просто установить обработчики для интересующих сигналов в форме &#8220;message::&lt;тип&gt;&#8221;, где вместо строки &lt;тип&gt; должен использоваться определенный тип сообщения (в следующем разделе приводится описание типов сообщений).</p>

<p>Приведенный выше фрагмент кода может быть записан также и следующим образом:</p>

<pre><code>GstBus *bus;

[..]

bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline);
gst_bus_add_signal_watch (bus);
g_signal_connect (bus, &quot;message::error&quot;, G_CALLBACK (cb_message_error), NULL);
g_signal_connect (bus, &quot;message::eos&quot;, G_CALLBACK (cb_message_eos), NULL);

[..]

</code></pre>

<p>В том случае, если вы не используете основной цикл обработки событий GLib, асинхронные сигналы о поступлении сообщений не будут доступны по умолчанию. Однако, вы можете установить специализированный синхронный обработчик, который будет активировать специализированный основной цикл обработки событий и использовать функцию <code>gst_bus_async_signal_func ()</code> для генерации сигналов (следует также обратиться к <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBus.html">документации</a> для получения дополнительной информации).</p>

<h3 id="message-types">7.2. Типы сообщений</h3>

<p>Фреймворк GStreamer использует несколько типов стандартных сообщений, которые могут передаваться посредством шины сообщений. Однако, механизм сообщений предусматривает расширение возможностей. Дополнительные типы сообщений могут объявляться на уровне плагинов, а на уровне приложений могут приниматься решения о том, следует ли исполнять специальный код при приеме подобных сообщений или просто игнорировать их. При разработке любых приложений настоятельно рекомендуется как минимум обрабатывать сообщения об ошибках и демонстрировать текст таких сообщений пользователю.</p>

<p>Все сообщения имеют поле источника, поле типа и поле времени. Поле источника сообщения может быть использовано для выяснения того, какой элемент сгенерировал сообщение. Например, при обработке сообщений некоторых типов большинству приложений будут интересны только те сообщения, которые были сгенерированы конвейером верхнего уровня (т.е., уведомления об изменениях состояний). Ниже приведен список всех типов сообщений с краткими описаниями их назначения, а также с пояснениями относительно разбора специфичных для сообщений этих типов данных.</p>

<ul>
<li><p>Уведомления с информацией об ошибках, предупреждениях или с дополнительной информацией: эти сообщения используются элементами в том случае, если необходимо проинформировать пользователя о состоянии конвейера. Сообщения об ошибках являются фатальными и приводят к прекращению передачи данных в рамках конвейера. Для продолжения эксплуатации конвейера ошибка должна быть устранена. Предупреждения не являются фатальными, тем не менее они указывают на проблему. Информационные сообщения являются сообщениями, не указывающими на проблему. Все эти сообщения передаются вместе с переменной типа <code>GError</code>, содержащей идентификатор типа ошибки, сообщение об ошибке и иногда строку с отладочным сообщением. Эти данные могут быть получены с помощью функций <code>gst_message_parse_error ()</code>, <code>_parse_waring ()</code> и <code>_parse_info ()</code>. Память, использованная для хранения как строки с сообщением об ошибке, так и строки с отладочным сообщением, должна быть освобождена после использования этих строк.</p></li>
<li><p>Уведомление об окончании мультимедийного потока: это уведомление генерируется в момент окончания мультимедийного потока. Состояние конвейера не будет изменено, но обработка мультимедийного потока будет остановлена. Приложения могут использовать данное сообщение для перехода к следующему элементу списка воспроизведения. После получения уведомления об окончании мультимедийного потока имеется возможность возвращения к определенной позиции в потоке. В этом случае проигрывание потока автоматически продолжится. Данное сообщение не имеет специфичных аргументов.</p></li>
<li><p>Тэги: генерируется в моменты, когда в мультимедийном потоке обнаруживаются метаданные. Данное сообщение может генерироваться неоднократно при работе с одним и тем же конвейером (т.е., как при изменении описывающих содержимое мультимедийного потока метаданных, таких, как имя артиста или название композиции, так и при изменении информации о самом потоке, такой, как количество сэмплов в секунду и скорость потока). Приложения должны производить внутреннее кэширование метаданных. Функция <code>gst_message_parse_tag ()</code> должна использоваться для разбора списка тэгов, после окончания которого к этому списку тэгов должна быть применена функция <code>gst_tag_list_unref ()</code> в том случае, если он более не требуется.</p></li>
<li><p>Изменения состояний: генерируется после успешного изменения состояния. Функция <code>gst_message_parse_state_changed ()</code> может использоваться для разбора информации о старом и новом состоянии, установленном в результате данного изменения.</p></li>
<li><p>Буферизация: генерируется в процессе кэширования мультимедийных потоков, передаваемых по сети. Имеется возможность извлечения значения показателя кэширования данных (в процентах) из сообщения путем извлечения значения свойства &#8220;buffer-percent&#8221; из структуры, возвращаемой функцией <code>gst_message_get_structure ()</code>. Для получения дополнительной информации также следует обратиться к <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-buffering.html">Главе 15, &#8220;Буферизация&#8221;</a>.</p></li>
<li><p>Сообщения элементов: это специальные сообщения, относящиеся к определенным элементам и обычно представляющие их дополнительные возможности. Сообщения, которые может отправлять определенный элемент, должны подробно описываться в документации этого элемента. В качестве примера можно привести элемент демультиплексора потоков формата QuickTime &#8220;qtdemux&#8221;, который может отправлять сообщение элемента &#8220;redirect&#8221; в определенных ситуациях, когда поток содержит инструкцию перенаправления.</p></li>
<li><p>Специфичные для приложения сообщения: любая информация из таких сообщений может быть извлечена путем получения структуры сообщения и чтения значений ее полей. Обычно эти сообщения могут безопасно игнорироваться.
Сообщения приложений главным образом предназначены для внутреннего использования в рамках приложений в тех случаях, когда приложению требуется передать информацию из какого-либо программного потока в главный программный поток. Это особенно полезно тогда, когда приложение использует сигналы от элементов (так как эти сигналы будут генерироваться в контексте программного потока, предназначенного для обработки мультимедийного потока).</p></li>
</ul>

<hr />

<p>Предыдущий раздел : <a href="06-bins.html">Контейнеры</a></p>

<p>Следующий раздел : <a href="08-pads.html">Точки соединения и возможности</a></p>

<p>Главная страница : <a href="../index.html">http://neon1ks.github.io/</a></p>



    </div>
    <script src="../js/jquery.js"></script>
    <script src="../js/bootstrap.js"></script>
  </body>
</html>
