<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Фреймворк GStreamer. Руководство разработчика приложений. Контейнеры</title>

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/librebay.css" rel="stylesheet">

    <link href="../css/highlight.css" rel="stylesheet">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body>

    <div class="container" role="main">



<h1 id="h1-bins">Фреймворк GStreamer. Руководство разработчика приложений. Контейнеры</h1>

<p>Оригинал: GStreamer Application Development Manual<br/>
Авторы: Wim Taymans, Steve Baker, Andy Wingo, Ronald S. Bultje, Stefan Kost<br/>
Дата публикации: 21 мая 2014 г.<br/>
Перевод: А.Панин<br/>
Дата перевода: 19 июня 2014 г.<br/>
Оригинал перевода: <a href="http://rus-linux.net/MyLDP/BOOKS/gstreamer/06-bins.html">Фреймворк GStreamer. Руководство разработчика приложений. Контейнеры</a></p>

<h2 id="bins">Глава 6. Контейнеры</h2>

<p>Контейнер является элементом, который может содержать другие элементы. Вы можете самостоятельно добавлять элементы в контейнер. Так как контейнер сам по себе является элементом, с ним можно работать точно так же, как и с другими элементами. Таким образом, вся информация из предыдущей главы (<a href="05-elements.html">&#8220;Элементы&#8221;</a>) может также использоваться при работе с контейнерами.</p>

<h3 id="what-are-bins">6.1. Чем являются контейнеры?</h3>

<p>Контейнеры позволяют вам сформировать группу связанных элементов в рамках одного логического элемента. Вам больше не придется работать с отдельными элементами, а вместо них вы будете работать с единственным элементом, контейнером. Мы увидим, что данный подход является особенно мощным в том случае, если вы планируете создавать сложные контейнеры, так как он позволяет вам разделить конвейер на фрагменты меньшего размера.</p>

<p>Контейнер также будет управлять находящимися в нем элементами. Он осуществляет изменения состояний элементов наряду с накоплением и передачей сообщений, распространяемых посредством шины сообщений.</p>

<figure>
<img src="images/bin-element-ru.png" alt="Рисунок 6.1. Изображение контейнера с несколькими элементами" />
<figcaption>Рисунок 6.1. Изображение контейнера с несколькими элементами</figcaption>
</figure>

<p>Существует единственный специализированный тип контейнера, доступный разработчику приложений на основе фреймворка GStreamer:</p>

<ul>
<li>Конвейер: контейнер общего назначения, который осуществляет синхронизацию работы элементов, а также управляет процессом передачи сообщений между ними. Контейнер верхнего уровня должен быть конвейером, поэтому каждое приложение должно иметь по крайней мере один контейнер.</li>
</ul>

<h3 id="creating-a-bin">6.2. Создание контейнера</h3>

<p>Контейнеры создаются таким же образом, как и другие элементы, т.е., с помощью фабрики элементов. Для этих целей также существуют вспомогательные функции (<code>gst_bin_new()</code> и <code>gst_pipeline_new()</code>). Для добавления элементов в контейнер или удаления элементов из контейнера вы можете использовать функции <code>gst_bin_add()</code> и <code>gst_bin_remove()</code>. Учтите, что контейнер, в который вы добавляете элемент, автоматически станет владельцем данного элемента. В том случае, если вы уничтожите контейнер, вместе с контейнером будет удалена ссылка на добавленный в него элемент. При удалении элемента из контейнера также будет произведено автоматическое удаление ссылки на элемент.</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElement *bin, *pipeline, *source, *sink;

  /* Инициализация */
  gst_init (&amp;argc, &amp;argv);

  /* Создание конвейера */
  pipeline = gst_pipeline_new (&quot;my_pipeline&quot;);
  bin = gst_bin_new (&quot;my_bin&quot;);
  source = gst_element_factory_make (&quot;fakesrc&quot;, &quot;source&quot;);
  sink = gst_element_factory_make (&quot;fakesink&quot;, &quot;sink&quot;);

  /* Первоочередное добавление элементов в контейнер */
  gst_bin_add_many (GST_BIN (bin), source, sink, NULL);
  /* Добавление контейнера в конвейер */
  gst_bin_add (GST_BIN (pipeline), bin);

  /* Связывание элементов */
  gst_element_link (source, sink);

[..]

}
</code></pre>

<p>Существуют различные функции для поиска элементов в контейнере. Наиболее часто используемыми функциями являются <code>gst_bin_get_by_name()</code> и <code>gst_bin_get_by_interface()</code>. Вы также можете осуществлять итерационный обход всех элементов из контейнера с помощью функции <code>gst_bin_iterate_elements()</code>. Обратитесь к описанию API класса <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBin.html">GstBin</a> для получения более подробной информации.</p>

<h3 id="custom-bins">6.3. Специализированные контейнеры</h3>

<p>Разработчик приложения может создавать собственные контейнеры, наполненные элементами для выполнения определенной задачи. Это позволит вам, к примеру, создать приложение для декодирования мультимедийных потоков формата Ogg/Vorbis исключительно с использованием следующих строк кода:</p>

<pre><code>int
main (int   argc,
      char *argv[])
{
  GstElement *player;

  /* Инициализация */
  gst_init (&amp;argc, &amp;argv);

  /* Создание элемента проигрывателя потока */
  player = gst_element_factory_make (&quot;oggvorbisplayer&quot;, &quot;player&quot;);

  /* Передача имени аудиофайла для воспроизведения */
  g_object_set (player, &quot;location&quot;, &quot;helloworld.ogg&quot;, NULL);

  /* Начало воспроизведения */
  gst_element_set_state (GST_ELEMENT (player), GST_STATE_PLAYING);
[..]
}
</code></pre>

<p>(Конечно же, это не самый удачный пример, так как уже существуют более мощные и гибкие специализированные контейнеры, такие, как контейнер &#8220;playbin&#8221;.)</p>

<p>Специализированные контейнеры могут быть созданы как на уровне плагинов, так и на уровне приложения. Вы сможете найти больше информации о создании специализированных контейнеров в <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/pwg/html/index.html">Руководстве разработчика плагинов (&#8220;Plugin Writers Guide&#8221;)</a>.</p>

<p>Примерами таких специализированных контейнеров являются элементы playbin и uridecodebin из пакета <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/gst-plugins-base-plugins/html/index.html">gst-plugins-base</a>.</p>

<h3 id="bins-manage-states-of-their-children">6.4. Контейнеры управляют состояниями своих дочерних элементов</h3>

<p>Контейнеры управляют состоянием элементов, которые в них содержатся. Если вы переводите контейнер (или конвейер, который является специальным типом контейнера верхнего уровня) в определенное состояние с помощью функции <code>gst_element_set_state()</code>, он позаботится о том, чтобы все содержащиеся в нем элементы также были переведены в это состояние. Это значит, что обычно необходимо всего лишь установить состояние конвейера верхнего уровня для запуска этого конвейера или его остановки.</p>

<p>Контейнер будет производить изменение состояния своих дочерних элементов начиная с элемента для вывода данных и заканчивая элементом для ввода данных. Такой подход позволяет быть уверенным в том, что элемент в конце конвейера будет готов к приему данных в момент, когда элемент в начале конвейера будет переведен в состояние &#8220;пауза&#8221; (PAUSED) или &#8220;проигрывается&#8221; (PLAYING). Аналогично при остановке конвейера элементы для вывода данных будут переведены в состояние &#8220;готовность к работе&#8221; (READY) или &#8220;отключено&#8221; (NULL) в первую очередь, что приведет к получению элементами в начале конвейера ошибки FLUSHING и остановке программных потоков для обработки мультимедийных потоков перед тем, как эти элементы также будут переведены в состояние &#8220;готовность к работе&#8221; (READY) или &#8220;отключено&#8221; (NULL).</p>

<p>Однако, следует учесть, что в том случае, если элементы добавляются в контейнер или в конвейер, который уже используется, т.е., в ходе обработки сигнала &#8220;pad-added&#8221;, их состояние не будет автоматически приведено в соответствие с текущим состоянием или целевым состоянием контейнера или конвейера, в который они были добавлены. Вместо этого вам придется самостоятельно перевести элементы в требуемое целевое состояние с помощью функции <code>gst_element_set_state()</code> или <code>gst_element_sync_state_with_parent()</code> при добавлении их в уже работающий конвейер.</p>

<hr />

<p>Предыдущий раздел : <a href="05-elements.html">Элементы</a></p>

<p>Следующий раздел : <a href="07-bus.html">Шина сообщений</a></p>

<p>Главная страница : <a href="../index.html">http://neon1ks.github.io/</a></p>



    </div>
    <script src="../js/jquery.js"></script>
    <script src="../js/bootstrap.js"></script>
  </body>
</html>
