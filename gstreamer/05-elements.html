<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Фреймворк GStreamer. Руководство разработчика приложений. Элементы</title>

    <link href="../favicon.ico" rel="shortcut icon" type="image/vnd.microsoft.icon" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/librebay.css" rel="stylesheet">

    <link href="../css/highlight.css" rel="stylesheet">
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>
  <body>

    <div class="container" role="main">
      <article class="content">



<h1 id="h1-elements">Фреймворк GStreamer. Руководство разработчика приложений. Элементы</h1>

<p>Оригинал: GStreamer Application Development Manual<br />
Авторы: Wim Taymans, Steve Baker, Andy Wingo, Ronald S. Bultje, Stefan Kost<br />
Дата публикации: 21 мая 2014 г.<br />
Перевод: А.Панин<br />
Дата перевода: 18 июня 2014 г.<br />
Оригинал перевода: <a href="http://rus-linux.net/MyLDP/BOOKS/gstreamer/05-elements.html">Фреймворк GStreamer. Руководство разработчика приложений. Элементы</a></p>

<h2 id="elements">Глава 5. Элементы</h2>

<p>Наиболее важным для разработчика приложений объектом фреймворка GStreamer является объект элемента типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html">GstElement</a>. Элемент является базовым строительным блоком для конвейера, предназначенного для обработки мультимедийных потоков. Классы всех тех различных высокоуровневых компонентов, которые вы будете использовать, унаследованы от класса <code>GstElement</code>. Каждый декодер, кодировщик, демультиплексор, элемент вывода аудио- и видеоданных фактически является экземпляром класса <code>GstElement</code>.</p>

<h3 id="what-are-elements">5.1. Чем являются элементы?</h3>

<p>Для разработчика приложений лучшей иллюстрацией элементов являются черные ящики. С одной стороны вы помещаете в них какие-либо данные, элемент обрабатывает эти данные каким-либо способом, после чего с другой стороны выводятся какие-либо другие данные. Для элемента декодера, например, вы могли бы поместить закодированные данные, а элемент вывел бы декодированные данные. В следующем разделе (<a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-pads.html">&#8220;Точки соединения и возможности&#8221;</a>) вы узнаете больше о передаче и получении данных от элементов, а также о том, как вы можете осуществить настройку элементов вашего приложения.</p>

<h4 id="source-elements">5.1.1. Элементы для ввода данных</h4>

<p>Элементы для ввода данных генерируют данные для последующей обработки в рамках конвейера, к примеру, читая их с диска или из буфера аудиокарты. На Рисунке 5.1. &#8220;Изображение элемента для ввода данных&#8221; показано изображение, которое мы будем использовать для обозначения элемента для ввода данных. Мы всегда изображаем выходную точку соединения в правой части элемента.</p>

<figure>
<img src="images/src-element-ru.png" alt="Рисунок 5.1. Изображение элемента для ввода данных" />
<figcaption>Рисунок 5.1. Изображение элемента для ввода данных</figcaption>
</figure>

<p>Элементы для ввода данных не принимают, а только генерируют данные. Вы можете увидеть это на рисунке, так как на нем изображена только выходная точка соединения (в правой части). Выходная точка соединения может исключительно передавать сгенерированные данные.</p>

<h4 id="filters-convertors-demuxers-muxers-and-codecs">5.1.2. Фильтры, конвертеры, демультиплексоры, мультиплексоры и кодеки</h4>

<p>Фильтры и подобные фильтрам элементы имеют как входные, так и выходные точки соединения. Они работают с данными, которые принимают с помощью входных точек соединения и впоследствии передают данные с помощью выходных точек соединения. Примерами таких элементов являются элементы изменения уровня звука (фильтры), элементы масштабирования изображения (конвертеры), демультиплексоры формата Ogg или декодеры формата Vorbis.</p>

<p>Подобные фильтрам элементы могут иметь произвольное количество входных и выходных точек соединения. Демультиплексор видеопотоков, например, будет иметь одну входную точку соединения и несколько (1-N) выходных точек соединения, по одной для каждого элементарного потока, содержащегося в контейнерном потоке. Декодеры, с другой стороны, будут иметь только по одной входной и выходной точке соединения.</p>

<figure>
<img src="images/filter-element-ru.png" alt="Рисунок 5.2. Изображение элемента фильтра" />
<figcaption>Рисунок 5.2. Изображение элемента фильтра</figcaption>
</figure>

<p>На Рисунке 5.2. &#8220;Изображение элемента фильтра&#8221; показано изображение подобного фильтру элемента, которое мы будем использовать. Элемент этого типа имеет одну входную и одну выходную точку соединения. С помощью входной точки соединения, изображенной слева, осуществляется прием входных данных; а выходные точки соединения все так же изображаются справа.</p>

<figure>
<img src="images/filter-element-multi-ru.png" alt="Рисунок 5.3. Изображение элемента фильтра с более чем одной выходной точкой соединения" />
<figcaption>Рисунок 5.3. Изображение элемента фильтра с более чем одной выходной точкой соединения</figcaption>
</figure>

<p>На Рисунке 5.3. &#8220;Изображение элемента фильтра с более чем одной выходной точкой соединения&#8221; показан другой подобный фильтру элемент, имеющий более одной выходной точки соединения. Примером такого элемента может быть демультиплексор формата Ogg для потока данных в формате Ogg, содержащего как видеопоток, так и аудиопоток. Одна выходная точка соединения будет содержать элементарный видеопоток, а вторая - элементарный аудиопоток. Демультиплексоры в общем случае будут генерировать сигналы при создании новой точки соединения. Благодаря этому разработчик приложения сможет осуществить обработку нового элементарного потока в рамках обработчика сигналов.</p>

<h4 id="sink-elements">5.1.3. Элементы для вывода данных</h4>

<p>Элементы для вывода данных являются конечными точками в конвейере для обработки мультимедийных потоков. Они принимают данные, но не передают ничего. С помощью элементов для вывода данных могут быть реализованы функции записи мультимедийных потоков на диск, вывода звука с помощью аудиокарты, а также вывода видео. На Рисунке 5.4. &#8220;Изображение элемента для вывода данных&#8221; показан элемент для вывода данных.</p>

<figure>
<img src="images/sink-element-ru.png" alt="Рисунок 5.4. Изображение элемента для вывода данных" />
<figcaption>Рисунок 5.4. Изображение элемента для вывода данных</figcaption>
</figure>

<h3 id="creating-a-gstelement">5.2. Создание экземпляра класса GstElement</h3>

<p>Простейший способ создания элемента заключается в использовании функции <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-make"><code>gst_element_factory_make()</code></a>. Эта функция принимает в качестве аргументов имя фабрики и имя создаваемого элемента. Имя элемента является произвольным идентификатором, который вы сможете использовать позднее, например, для поиска элемента в контейнере. Это имя также будет использоваться в выводимых отладочных сообщениях. Вы можете передать значение <code>NULL</code> в качестве значения аргумента имени для получения уникального стандартного имени элемента.</p>

<p>В момент, когда элемент перестанет быть нужным, вы должны будете удалить ссылку на него с помощью функции <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstObject.html#gst-object-unref"><code>gst_object_unref()</code></a>. Данная функция уменьшает значение счетчика ссылок элемента на 1. Значение счетчика ссылок элемента при создании равно 1. Элемент полностью уничтожается в момент, когда значение счетчика ссылок снижается до 0.</p>

<p>Следующий пример<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote"><sup>1</sup></a> иллюстрирует методику создания элемента с именем <code>source</code> с помощью фабрики элементов с именем <code>fakesrc</code>. В нем осуществляется проверка успешности создания элемента. После проверки единственная ссылка на созданный элемент удаляется.</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElement *element;

  /* Инициализация библиотеки фреймворка GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Создание элемента */
  element = gst_element_factory_make (&quot;fakesrc&quot;, &quot;source&quot;);
  if (!element) {
    g_print (&quot;Не удалось создать элемент типа 'fakesrc'\n&quot;);
    return -1;
  }

  gst_object_unref (GST_OBJECT (element));

  return 0;
}
</code></pre>

<p>Функция <code>gst_element_factory_make()</code> на самом деле является оберткой для комбинации из двух функций. Объект типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html"><code>GstElement</code></a> создается с помощью фабрики элементов. Для создания элемента вам необходимо получить доступ к объекту фабрики элементов типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html"><code>GstElementFactory</code></a> с использованием уникального имени фабрики. Эта задача решается с помощью функции <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-find"><code>gst_element_factory_find()</code></a>.</p>

<p>Следующий фрагмент кода используется для получения фабрики, которая может быть использована для создания элемента типа <code>fakesrc</code>, являющегося элементом для фиктивного ввода данных. Функция <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html#gst-element-factory-create"><code>gst_element_factory_create()</code></a> будет использовать фабрику элементов для создания элемента с заданным именем.</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElementFactory *factory;
  GstElement * element;

  /* Инициализация библиотеки фреймворка GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Создание элемента, метод #2 */
  factory = gst_element_factory_find (&quot;fakesrc&quot;);
  if (!factory) {
    g_print (&quot;Не удалось найти фабрику типа 'fakesrc'\n&quot;);
    return -1;
  }
  element = gst_element_factory_create (factory, &quot;source&quot;);
  if (!element) {
    g_print (&quot;Не удалось создать элемент, учитывая то, что соответствующая фабрика уже существует!\n&quot;);
    return -1;
  }

  gst_object_unref (GST_OBJECT (element));

  return 0;
}
</code></pre>

<h3 id="using-an-element-as-a-gobject">5.3. Использование элемента как объекта типа GObject</h3>

<p>Элемент типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html"><code>GstElement</code></a> может иметь несколько свойств, которые реализованы на основе стандартных свойств объектной модели <code>GObject</code>. Следовательно, будут поддерживаться обычные методы объектной модели <code>GObject</code> для запроса, установки и получения значений свойств, а также для работы с метаданными параметров объектов типа <code>GParamSpec</code>.</p>

<p>Каждый элемент типа <code>GstElement</code> наследует как минимум одно свойство от своего родителя типа <code>GstObject</code>: свойство &#8220;name&#8221;. Это свойство представляет имя, которое вы передавали функции <code>gst_element_factory_make()</code> или <code>gst_element_factory_create()</code>. Вы можете получить и установить значение данного свойства с помощью функций <code>gst_object_set_name()</code> и <code>gst_object_get_name()</code> или использовать механизм свойств объектной модели <code>GObject</code> таким же образом, как показано ниже.</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElement *element;
  gchar *name;

  /* Инициализация библиотеки фреймворка GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Создание элемента */
  element = gst_element_factory_make (&quot;fakesrc&quot;, &quot;source&quot;);

  /* Получение имени элемента */
  g_object_get (G_OBJECT (element), &quot;name&quot;, &amp;name, NULL);
  g_print (&quot;Имя элемента: '%s'.\n&quot;, name);
  g_free (name);

  gst_object_unref (GST_OBJECT (element));

  return 0;
}
</code></pre>

<p>Большинство плагинов предоставляет дополнительные свойства для передачи большего объема информации о своей конфигурации или для непосредственного выполнения конфигурации элемента. Утилита <strong>gst-inspect</strong> является полезным инструментом, предназначенным для получения значений свойств определенного элемента, причем она также выполняет исследование выбранного свойства для предоставления краткого описания его назначения, типов параметров и диапазона поддерживаемых значений. Обратитесь <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/section-checklist-applications.html#section-applications-inspect">разделу &#8220;gst-inspect&#8221;</a> из приложений для ознакомления с подробным описанием возможностей утилиты <strong>gst-inspect</strong>.</p>

<p>Для получения дополнительной информации о свойствах в рамках объектной модели <code>GObject</code> мы рекомендуем вам ознакомиться с со следующими документами: <a href="http://developer.gnome.org/gobject/stable/rn01.html">&#8220;Руководство по работе с объектной моделью GObject&#8221;</a> и <a href="http://developer.gnome.org/gobject/stable/pt01.html">&#8220;Введение в систему объектов библиотеки Glib&#8221;</a>.</p>

<p>Элемент типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElement.html"><code>GstElement</code></a> также предоставляет различные сигналы объектной модели <code>GObject</code>, которые могут использоваться в качестве гибкого механизма для работы с функциями обратного вызова. Здесь вы также можете прибегнуть к использованию утилиты <strong>gst-inspect</strong> для ознакомления с тем, какие сигналы определенный элемент поддерживает. Комбинация сигналов и свойств является простейшим механизмом взаимодействия элементов и приложений.</p>

<h3 id="more-about-element-factories">5.4. Подробнее о фабриках элементов</h3>

<p>В предыдущем разделе мы кратко описали объект типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstElementFactory.html"><code>GstElementFactory</code></a> как объект, позволяющий создавать экземпляры классов элементов. Фабрики элементов, однако, могут выполнять гораздо больше функций. Фабрики элементов являются базовыми типами, получаемыми из реестра фреймворка GStreamer, поэтому они описывают все плагины и элементы, которые могут создаваться средствами фреймворка GStreamer. Это значит, что фабрики элементов полезны для автоматизированного создания объектов элементов таким образом, как это делается в реализациях элементов для автоматического подключения плагинов, а также для создания списков доступных элементов.</p>

<h4 id="getting-information-about-an-element-using-a-factory">5.4.1. Получение информации об элементе с помощью фабрики</h4>

<p>Такие инструменты, как <strong>gst-inspect</strong> могут выводить некоторый объем такой обобщенной информации об элементе, как имя разработчика, полное (и короткое) название, класс и категория соответствующего плагина. Категория может использоваться для получения типа элемента, который может быть создан с помощью данной фабрики элементов. Примерами категорий являются <code>Codec/Decoder/Video</code> (декодер видеопотоков), <code>Codec/Encoder/Video</code> (кодировщик видеопотоков), <code>Source/Video</code> (генератор видеопотоков), <code>Sink/Video</code> (вывод видеопотоков) и, разумеется, все эти категории также применимы и к аудиопотокам. Также существуют категории демультиплексоров <code>Codec/Demux</code> и мультиплексоров <code>Codec/Muxer</code> наряду с множеством других категорий. Утилита <strong>gst-inspect</strong> при необходимости выведет список всех фабрик, а команда <strong>gst-inspect &lt;имя фабрики&gt;</strong> выведет всю описанную выше информацию, а также множество дополнительных сведений о фабрике.</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElementFactory *factory;

  /* Инициализация библиотеки фреймворка GStreamer */
  gst_init (&amp;argc, &amp;argv);

  /* Получение объекта фабрики */
  factory = gst_element_factory_find (&quot;fakesrc&quot;);
  if (!factory) {
    g_print (&quot;У вас не установлен модуль для создания элемента типа 'fakesrc'!\n&quot;);
    return -1;
  }

  /* Вывод информации */
  g_print (&quot;Элемент '%s' относится к категории %s.\n&quot;
           &quot;Описание: %s\n&quot;,
           gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)),
           gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_KLASS),
           gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_DESCRIPTION));

  return 0;
}
</code></pre>

<h4 id="get-list-element-factory">5.4.2 Получения списка фабрик элементов</h4>

<p>Ранее была функция <code>gst_registry_pool_feature_list (GST_TYPE_ELEMENT_FACTORY)</code> для получения списка всех фабрик элементов, о которых известно фреймворку GStreamer. Но эту функцию убрали из кода.</p>

<p>Сейчас для получения списка фабрик элементов используется функция <a href="https://developer.gnome.org/gstreamer/stable/GstElementFactory.html#gst-element-factory-list-get-elements"><code>gst_element_factory_list_get_elements ()</code></a> возвращающая <a href="https://developer.gnome.org/glib/unstable/glib-Doubly-Linked-Lists.html#GList"><code>GList</code></a> со списком элементов <a href="https://developer.gnome.org/gstreamer/stable/GstElementFactory.html"><code>GstElementFactory</code></a>.</p>

<pre><code>GList *
gst_element_factory_list_get_elements (GstElementFactoryListType type,
                                       GstRank minrank);
</code></pre>

<p>В качестве первого аргумента функции передается тип фабрики элементов. Все типы перечислены на странице <a href="https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/GstElementFactory.html">GstElementFactory: GStreamer 1.0 Core Reference Manual</a> в разделе <em>Types and Values</em>. Например, есть макрос <code>GST_ELEMENT_FACTORY_TYPE_ANY</code> соответствующий любому типу.</p>

<p>Второй аргумент функции ранг фабрики элементов: <a href="https://developer.gnome.org/gstreamer/stable/GstPluginFeature.html#GstRank"><code>GstRank</code></a>. Для указания ранга имеется 4 макроса:</p>

<ul>
<li><code>GST_RANK_NONE</code> &mdash; will be chosen last or not at all</li>
<li><code>GST_RANK_MARGINAL</code> &mdash; unlikely to be chosen</li>
<li><code>GST_RANK_SECONDARY</code> &mdash; likely to be chosen</li>
<li><code>GST_RANK_PRIMARY</code> &mdash; will be chosen first</li>
</ul>

<p>Пример использования:</p>

<pre><code>GList *elements = gst_element_factory_list_get_elements(GST_ELEMENT_FACTORY_TYPE_ANY,
                                                        GST_RANK_NONE);
GstElementFactory *elementFact;
for (l = elements; l != NULL; l = l-&gt;next) {
    elementFact = (GstElementFactory *)(l-&gt;data);

    // Первый способ получения имени
    g_print(&quot;factory: %s\n&quot;, GST_OBJECT_NAME(elementFact));

    printf(&quot;Элемент '%s' относится к категории %s.\n&quot;
           &quot;Описание: %s\n\n&quot;,
           gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(elementFact)),
           gst_element_factory_get_metadata(elementFact, GST_ELEMENT_METADATA_KLASS),
           gst_element_factory_get_metadata(elementFact, GST_ELEMENT_METADATA_DESCRIPTION));
}

gst_plugin_feature_list_free(elements);
</code></pre>

<h4 id="finding-out-what-pads-an-element-can-contain">5.4.3. Установление точек соединения, поддерживаемых элементом</h4>

<p>Возможно, наиболее мощной возможностью фабрик элементов является хранение полных описаний точек соединения, которые элемент из плагина может генерировать, а также информации о возможностях этих точек соединения (говоря проще: информации о том, какие типы мультимедийных потоков могут передаваться через эти точки соединения) без необходимости непосредственной загрузки соответствующих плагинов в память. Эта информация может использоваться для формирования списка, предназначенного для выбора кодировщиков, или для реализации механизмов автоматического подключения плагинов мультимедийных проигрывателей. Все существующие мультимедийные проигрыватели на основе фреймворка GStreamer и элементы с поддержкой механизма автоматической подгрузки плагинов работают описанным образом. Мы рассмотрим эти возможности более подробно по мере рассмотрения объектов типов GstPad и GstCaps в следующем разделе: <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-pads.html">&#8220;Точки соединения и возможности&#8221;</a>.</p>

<h3 id="linking-elements">5.5. Связывание элементов</h3>

<p>Связывая элемент для ввода данных с подобными фильтрам элементами и в конце концов с элементом для вывода данных, вы формируете конвейер для обработки мультимедийных потоков. Данные будут передаваться через элементы. Это базовая концепция обработки мультимедийных потоков в рамках фреймворка GStreamer.</p>

<figure>
<img src="images/linked-elements-ru.png" alt="Рисунок 5.5. Изображение трех связанных элементов" />
<figcaption>Рисунок 5.5. Изображение трех связанных элементов</figcaption>
</figure>

<p>Связав эти три элемента, мы создали очень простую цепочку элементов. В результате этого выходная точка соединения элемента для ввода данных (&#8220;element1&#8221;) будет использована в качестве источника данных для подобного фильтру элемента (&#8220;element2&#8221;). Подобный фильтру элемент будет выполнять какие-либо манипуляции с данными и передавать результирующие данные последнему элементу для вывода данных (&#8220;element3&#8221;).</p>

<p>Представьте, что приведенный выше граф является простым декодером для аудиопотоков формата Ogg/Vorbis. В качестве источника данных выступает элемент для ввода данных с диска, который читает расположенный на диске файл. Вторым элементом является аудиодекодер для формата Ogg/Vorbis. Элементом для вывода данных с целью проигрывания декодированного аудиопотока используется ваша аудиокарта. Мы будем использовать данный простой граф для создания проигрывателя файлов формата Ogg/Vorbis позднее в данном руководстве.</p>

<p>В форме кода данный граф может быть представлен аналогичным образом:</p>

<pre><code>#include &lt;gst/gst.h&gt;

int
main (int   argc,
      char *argv[])
{
  GstElement *pipeline;
  GstElement *source, *filter, *sink;

  /* Инициализация */
  gst_init (&amp;argc, &amp;argv);

  /* Создание конвейера */
  pipeline = gst_pipeline_new (&quot;my-pipeline&quot;);

  /* Создание элементов */
  source = gst_element_factory_make (&quot;fakesrc&quot;, &quot;source&quot;);
  filter = gst_element_factory_make (&quot;identity&quot;, &quot;filter&quot;);
  sink = gst_element_factory_make (&quot;fakesink&quot;, &quot;sink&quot;);

  /* Элементы должны быть добавлены в конвейер перед связыванием */
  gst_bin_add_many (GST_BIN (pipeline), source, filter, sink, NULL);

  /* Связывание */
  if (!gst_element_link_many (source, filter, sink, NULL)) {
    g_warning (&quot;Не удалось связать элементы!&quot;);
  }

[..]

}
</code></pre>

<p>Для случаев, когда необходимо реализовать более специфичный метод взаимодействия элементов, также существуют функции <code>gst_element_link()</code> и <code>gst_element_link_pads()</code>. При этом вы также можете получить ссылки на отдельные точки соединения и связать их с помощью различных функций <code>gst_pad_link_*()</code>. Обратитесь к документации API для получения более подробной информации.</p>

<p>Важно: вы должны добавлять элементы в контейнер или в конвейер перед их связыванием, так как при добавлении элемента в контейнер уничтожаются все существующие связи этого элемента. Также вы не можете непосредственно связывать элементы, не находящиеся в одном контейнере или в одном конвейере; в том случае, если вы хотите связать элементы или их точки соединения при условии использования ими различных уровней иерархии, вам придется использовать виртуальные точки соединения (подробнее о виртуальных точках соединения будет сказано позднее в разделе <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/section-pads-ghost.html">&#8220;Виртуальные точки соединения&#8221;</a>).</p>

<h3 id="element-states">5.6. Состояния элементов</h3>

<p>После создания элемент в действительности не будет выполнять никаких действий. Вам придется изменить состояние элемента для того, чтобы начать работу с ним. В рамках фреймворка GStreamer объявлено четыре состояния элементов, каждое из которых имеет очень специфичное значение. Эти четыре состояния:</p>

<ul>
<li><p><code>GST_STATE_NULL</code>: это стандартное состояние &#8220;отключено&#8221;. В данном состоянии не резервируются ресурсы, поэтому перевод элемента в это состояние приведет к освобождению всех ранее зарезервированных ресурсов. Элемент должен находиться в этом состоянии в момент, когда значение его счетчика ссылок достигает нуля и он уничтожается.</p></li>
<li><p><code>GST_STATE_READY</code>: в состоянии готовности элемент резервирует для всех своих глобальных ресурсов, т. е., ресурсов, которые могут использоваться при работе с потоками. При реализации данного состояния вы можете задуматься об открытии устройств, резервировании памяти для буферов и аналогичных действиях. Однако, в данном состоянии поток данных не открывается, поэтому указатели позиций в потоке автоматически обнуляются. В том случае, если поток данных был предварительно открыт, в данном состоянии он должен быть закрыт, а позиции, свойства и другие параметры потока данных должны быть обнулены.</p></li>
<li><p><code>GST_STATE_PAUSED</code>: в данном состоянии элемент осуществляет открытие потока данных, но активно не обрабатывает его. Элемент имеет возможность изменять позицию в потоке данных, читать и обрабатывать данные, а также выполнять аналогичные действия для подготовки к воспроизведению, которое начнется в момент изменения состояния на &#8220;проигрывается&#8221; (PLAYING), но при этом элемент не имеет возможности проигрывания данных из потока, что приведет к запуску таймера. В общем, состояние &#8220;пауза&#8221; (PAUSED) аналогично состоянию &#8220;проигрывается&#8221; (PLAYING) за исключением того, что в первом состоянии таймер не работает.</p>

<p>Элементы, состояние которых изменяется на &#8220;пауза&#8221; (PAUSED), должны подготовить себя к переходу в состояние &#8220;проигрывается&#8221; (PLAYING) так быстро, как это возможно. Элементы для вывода аудио- или видеоданных, к примеру, должны ожидать прибытия данных и сохранять их для того, чтобы начать воспроизводить сразу же после изменения состояния. Также элементы для показа видео могут выводить первый полученный кадр (так как это не повлияет на состояние таймера). Приложения с автоматическим подключением плагинов могут использовать такой же переход из состояния в состояние для окончательного формирования конвейера. Однако, при работе с большинством других элементов, таких, как кодеки или фильтры, не требуется выполнения каких либо действий в данном состоянии.</p></li>
<li><p>GST_STATE_PLAYING: в состоянии &#8220;проигрывается&#8221; (PLAYING) элемент выполняет те же действия, что и в состоянии &quot;пауза' (PAUSED), но при этом таймер работает.</p></li>
</ul>

<p>Вы можете изменить состояние элемента с помощью функции <code>gst_element_set_state()</code>. В том случае, если вы переведете элемент в другое состояние, фреймворк GStreamer немедленно осуществит внутренний обход всех промежуточных состояний. Таким образом, в том случае, если вы переведете элемент из состояния &#8220;отключено&#8221; (NULL) в состояние &#8220;проигрывается&#8221; (PLAYING), фреймворк GStreamer в процессе перевода элемента в заданное состояние осуществит внутренний перевод элемента в состояния &#8220;готовность к работе&#8221; (READY) и &#8220;пауза&#8221; (PAUSED).</p>

<p>При переводе в состояние &#8220;проигрывается&#8221; (<code>GST_STATE_PLAYING</code>) конвейеры будут обрабатывать данные автоматически. Какой-либо итерации не требуется. В рамках библиотеки GStreamer будет выполнена внутренняя операция создания программных потоков, которые возьмут эту задачу на себя. Библиотека GStreamer также позаботится о передаче сообщений из программного потока конвейера в собственный программный поток приложения с помощью объекта шины сообщений типа <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/stable/gstreamer/html/GstBus.html"><code>GstBus</code></a>. Обратитесь к <a href="http://gstreamer.freedesktop.org/data/doc/gstreamer/head/manual/html/chapter-bus.html">Главе 7 &#8220;Шина сообщений&#8221;</a> для получения более подробной информации.</p>

<p>В момент, когда вы переводите контейнер или конвейер в определенное целевое состояние, в большинстве случаев данные об изменении состояния будут автоматически передаваться всем элементам, расположенным в контейнере или в конвейере, поэтому обычно необходимо изменить состояние исключительно конвейера верхнего уровня для запуска или остановки всего конвейера. Однако, при динамическом добавлении элементов в уже запущенный конвейер, т.е., при обработке сигнала &#8220;pad-added&#8221;, вам придется перевести элемент в желаемое целевое состояние самостоятельно с помощью функции <code>gst_element_set_state()</code> или <code>gst_element_sync_state_with_parent()</code>.</p>

<hr />

<p>Предыдущий раздел : <a href="04-init.html">Инициализация библиотеки фреймворка GStreamer</a></p>

<p>Следующий раздел : <a href="06-bins.html">Контейнеры</a></p>

<p>Главная страница : <a href="../index.html">http://neon1ks.github.io/</a></p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>Код для данного примера автоматически извлечен из документации и добавлен в директорию <code>tests/examples/manual</code> архива исходного кода фреймворка GStreamer. <a href="#fnref:1" title="return to body" class="reversefootnote">&#160;&#8617;&#xfe0e;</a></p>
</li>

</ol>
</div>



      </article>
    </div>
  </body>
</html>
