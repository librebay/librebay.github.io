# Фреймворк GStreamer. Руководство разработчика приложений. Буферы и события [h1-buffers-and-events]

Оригинал: GStreamer Application Development Manual  
Авторы: Wim Taymans, Steve Baker, Andy Wingo, Ronald S. Bultje, Stefan Kost  
Дата публикации: 21 мая 2014 г.  
Перевод: А.Панин  
Дата перевода: 19 июня 2014 г.  
Оригинал перевода: [Фреймворк GStreamer. Руководство разработчика приложений. Буферы и события](http://rus-linux.net/MyLDP/BOOKS/gstreamer/09-data.html)


## Глава 9. Буферы и события [buffers-and-events]

Процесс передачи данных по конвейеру тесно связан с использованием комбинации буферов и событий. Буферы содержат сами мультимедийные данные. События используются для передачи такой управляющей информации, как информация о перемещении в потоке данных и уведомления о завершении этого потока. Все операции передачи данных в рамках конвейера выполняются автоматически в процессе работы конвейера. Данная глава предназначена в первую очередь для объяснения принципов работы описанного механизма; вам не придется как-либо вмешиваться в его работу.

### 9.1. Буферы [buffers]

Буферы содержат данные, которые будут передаваться посредством созданного вами конвейера. Элемент для ввода данных обычно создает новый буфер и передает его с помощью точки соединения следующему элементу в цепочке. При использовании инфраструктуры фреймворка GStreamer для создания конвейера обработки мультимедийных данных вам не придется работать с буферами самостоятельно; элементы сделают это за вас.

Помимо прочих вещей, буфер состоит из:

- Указателей на объекты памяти. Объекты памяти инкапсулируют фрагмент памяти.

- Метки времени для буфера.

- Счетчика ссылок, который указывает на то, как много элементов использует данный буфер. Этот счетчик ссылок будет использоваться для уничтожения буфера в момент, когда на него не будет ссылаться ни один из элементов.

- Флагов буфера.

В простейшем случае при создании буфера для него резервируется память, в нее помещаются данные, после чего буфер передается следующему элементу. Этот элемент читает данные, выполняет с ними какие-либо действия (такие, как декодирование с записью результирующих данных в предварительно созданный новый буфер) и удаляет ссылку на полученный буфер. Это действие приводит к освобождению зарезервированной для хранения данных памяти и уничтожению буфера. Типичный декодер аудио- или видеопотоков работает именно так.

Хотя существуют и более сложные сценарии. Элементы могут непосредственно модифицировать данные буферов, т.е., изменять данные без резервирования нового буфера. Также элементы могут записывать данные в область памяти, связанную с аппаратным обеспечением (в такую, как память устройств видеозахвата) или зарезервированную сервером оконной системы X (с использованием расширения XShm). Буферы могут предназначаться как только для чтения данных из них, так и для других операций.

### 9.2. События [events]

События являются сигналами управления, которые отправляются как по направлению, так и против направления конвейера вместе с буферами. События, отправляемые по направлению конвейера, уведомляют целевые элементы об изменениях состояния потока. Набор возможных вариантов событий включает события перемещения в потоке, события опустошения буферов, события окончания потока и.т.д. События, отправляемые против направления конвейера, используются для осуществления взаимодействий как по схеме приложение-элемент, так и по схеме элемент-элемент с целью запроса выполнения таких изменений состояния потока, как переходы к заданным позициям. Для приложений важны исключительно события, отправляемые против направления конвейера. События, отправляемые по направлению конвейера, описаны только для того, чтобы читатель составил более полное представление о концепции механизма передачи данных.

Так как большая часть приложений использует единицы измерения времени для перехода к заданной позиции в потоке, в нашем примере они также будут использоваться:

```
static void
seek_to_time (GstElement *element,
	      guint64     time_ns)
{
  GstEvent *event;

  event = gst_event_new_seek (1.0, GST_FORMAT_TIME,
			      GST_SEEK_FLAG_NONE,
			      GST_SEEK_METHOD_SET, time_ns,
			      GST_SEEK_TYPE_NONE, G_GUINT64_CONSTANT (0));
  gst_element_send_event (element, event);
}
```

Функция `gst_element_seek ()` является вспомогательной функцией, позволяющей использовать описанную методику перехода к позиции в потоке. Этот пример приведен главным образом для демонстрации методики работы с событиями.

----------

Предыдущий раздел : [Точки соединения и возможности](08-pads.html)

Следующий раздел : [Ваше первое приложение](10-helloworld.html)

Главная страница : [http://neon1ks.github.io/](../index.html)